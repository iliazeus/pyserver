#!/usr/bin/env python3

import atexit
from code import InteractiveConsole
from os import unlink, getenv
from signal import signal, SIGINT, SIGTERM
from socket import socket, AF_UNIX
import sys


class PysessionConsole(InteractiveConsole):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.status = None

    def showtraceback(self, *args, **kwargs):
        self.status = 1
        return super().showtraceback(*args, **kwargs)

    def showsyntaxerror(self, *args, **kwargs):
        self.status = 2
        return super().showsyntaxerror(*args, **kwargs)


session = {}

lsock = socket(AF_UNIX)

sockpath = getenv("PYSESSION_SOCKET") or "./.py.sock"
lsock.bind(sockpath)
atexit.register(unlink, sockpath)

lsock.listen()
signal(SIGINT, lambda _, _2: sys.exit(0))
signal(SIGTERM, lambda _, _2: sys.exit(0))

while True:
    sock, _ = lsock.accept()
    f = sock.makefile("rw", buffering=1)
    sock.close()

    with f:
        l = int(f.readline())
        argv = [f.read(l)]
        argc = int(f.readline())
        for i in range(argc):
            l = int(f.readline())
            argv.append(f.read(l))
        f.read(1)
        session["argv"] = [*argv]

        sys.stdin = f
        session["stdin"] = f

        sys.stdout = f
        session["stdout"] = f

        cons = PysessionConsole(locals=session)
        session["exit"] = lambda s: cons.__setattr__("status", s)

        if argv[-1][-1] == "i":
            cons.interact()
        else:
            for line in f:
                cons.push(line)
                if cons.status is not None:
                    break
            else:
                cons.push("")

            if argv[-1][-1] != "i":
                f.write(f"\n{cons.status or 0}")
