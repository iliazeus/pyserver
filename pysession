#!/usr/bin/env python

from argparse import ArgumentParser
from array import array
import atexit
from code import InteractiveConsole
from os import dup, dup2, getenv, close, unlink
from signal import signal, SIGINT, SIGTERM
from socket import socket, AF_UNIX, CMSG_LEN, SCM_RIGHTS, SOL_SOCKET
import struct
import sys
from typing import NamedTuple


class Request(NamedTuple):
    fds: array[int]
    argv: list[str]
    environ: list[str]


class Reader:
    mem: memoryview

    def __init__(self, b: bytes):
        self.mem = memoryview(b)

    def read_int(self) -> int:
        val = self.mem[:4].cast("i")[0]
        self.mem = self.mem[4:]
        return val

    def read_str(self, encoding="utf-8") -> str:
        val_len = self.read_int()
        val = str(self.mem[:val_len], encoding)
        self.mem = self.mem[val_len:]
        return val

    def read_str_list(self, encoding="utf-8") -> list[str]:
        count = self.read_int()
        val = []
        for _ in range(count):
            val.append(self.read_str())
        return val


def receive_request(sock: socket) -> Request:
    fds = array("i")

    msg, ancdata, _flags, _addr = sock.recvmsg(8, CMSG_LEN(12))
    version, req_len = struct.unpack("ii", msg)
    assert version == 1

    for cmsg_level, cmsg_type, cmsg_data in ancdata:
        if cmsg_level == SOL_SOCKET and cmsg_type == SCM_RIGHTS:
            fds.frombytes(cmsg_data[:12])

    msg = Reader(sock.recv(req_len))
    argv = msg.read_str_list()
    environ = msg.read_str_list()

    return Request(fds, argv, environ)


def send_response(sock: socket, exitcode: int):
    msg = struct.pack("i", exitcode)
    sock.send(msg)


def run_cli(session: dict, req: Request) -> int:
    class PysessionConsole(InteractiveConsole):
        def __init__(self, *args, **kwargs):
            super().__init__(*args, **kwargs)
            self.status = None

        def showtraceback(self, *args, **kwargs):
            self.status = 1
            return super().showtraceback(*args, **kwargs)

        def showsyntaxerror(self, *args, **kwargs):
            self.status = 2
            return super().showsyntaxerror(*args, **kwargs)

    # can't just assign to sys.stdX because of:
    # https://github.com/python/cpython/issues/36029
    orig_fds = [-1, -1, -1]
    for i in range(3):
        orig_fds[i] = dup(i)
        dup2(req.fds[i], i, inheritable=True)
        close(req.fds[i])

    try:
        cli = ArgumentParser(
            prog="py",
            description="pysession client (https://github.com/iliazeus/pysession)",
        )
        cli.add_argument(
            "-i", "--interactive", action="store_true", help="interactive mode"
        )
        cli.add_argument("-c", "--command", nargs="*", help="run code passed via args")
        cli.add_argument("-p", "--print", nargs="*", help="pring args")
        cli.add_argument("argv", nargs="*")
        cli = cli.parse_args(req.argv)

        if len(req.argv) == 1:
            cli.interactive = sys.stdin.isatty()

        session["stdin"] = sys.stdin
        session["stdout"] = sys.stdout
        session["stderr"] = sys.stderr
        session["argv"] = cli.argv
        session["env"] = dict(kv.split("=", 1) for kv in req.environ)

        cons = PysessionConsole(locals=session)

        if cli.interactive:
            import readline  # side-effect imports, yay!

            cons.interact()
            return 0

        input_lines = sys.stdin

        if cli.command is not None or cli.print is not None:
            input_lines = []

        if cli.command is not None and len(cli.command) > 0:
            input_lines = cli.command

        for line in input_lines:
            cons.push(line)
            if cons.status is not None:
                break
        else:
            cons.push("")

        if cli.print is not None:
            for item in cli.print:
                cons.push(f"print({item})")

        return cons.status or 0

    except SystemExit as e:
        return e.code

    except:
        return -1

    finally:
        sys.stdout.flush()
        sys.stderr.flush()
        for i in range(3):
            dup2(orig_fds[i], i)
            close(orig_fds[i])


def run_server(listen_sock: socket):
    session = {}
    while True:
        sock, _ = listen_sock.accept()
        with sock:
            req = receive_request(sock)
            code = run_cli(session, req)
            send_response(sock, code or 0)


def main():
    signal(SIGINT, lambda _, _2: sys.exit(0))
    signal(SIGTERM, lambda _, _2: sys.exit(0))

    listen_sock_path = getenv("PYSESSION_SOCKET") or "./.py.sock"

    listen_sock = socket(AF_UNIX)
    listen_sock.bind(listen_sock_path)
    atexit.register(unlink, listen_sock_path)

    listen_sock.listen()
    run_server(listen_sock)


if __name__ == "__main__":
    exit(main())
